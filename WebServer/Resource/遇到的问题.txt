
时间：2020.02.19
  问题一：
    在编写完整个服务器雏形后，对服务器进行了测试，但测试发现，浏览器发来的第一个页面请求会很快就响应，
    但是后续如果只有单个浏览器页面发来请求时，这时这个页面就会被卡住，一直得不到服务器的响应，只有后续
    再打开浏览器页面发送请求时，前一个页面的请求才会得到相应，后续的浏览器页面请求都是这种情况;

    当时因为这个问题被卡住了好几天，开始我以为是epoll_wait的问题，我就百度找关于epoll_wait的开发问题，
    但是百度上能找到的都是关于epoll_wait如何使用，或者没有把epollfd和listenfd都设置为非阻塞而踩坑的这些情况；
    一直没有我想要的答案；后来找了许久，终于看到一篇博客描述的情况和我的相识，结果也确实如此。
    其实这个问题还是关于epoll_wait的，在我最初的理解是：加入epoll中的fd每有一个事件发生就报告一个事件，
    所以我的connect函数是只接受一个报告的fd，但事实却是：当有多个同一个端口的连接请求时，epoll加入的
    listenfd不管有多少个事件，都只会报告一次读事件给listenfd， 如果我们只接受一次报告的连接，那么后续
    的连接请求就被搁置在内核缓存区，直到有新的请求到来（不管是listenfd的还是其他已连接的fd），前面被搁置
    的请求才能得到处理，但是后续来到的请求还是会像之前被搁置的请求一样被搁置；解决方法就是：当listenfd事件
    发生时，就循环接受连接请求，直到没有连接请求。

  问题二：
    关于线程池的编写，开始我学习到的线程池是使用pthread库提供的端口来写了的，但是在看了别人写的线程池之后
    就发现使用pthread提供的函数来写的话会非常麻烦，尤其是需要对任务函数和任务函数的参数进行封装，然后以这
    个封装来传递给pthread，这个过程非常复杂麻烦，所以我就想用简单一点的方式。因为之前看c++11特性有说到c++11
    提供了对多线程的支持，也就是thread库，后面就深入学习了怎么使用；
    写代码时，还是有一个很重要的点就是任务函数和任务函数参数的传递，想到了bind，但是使用还是有问题，
    后面学习了别人怎么使用bind封装一个任务函数和任务函数参数，就解决了，关于任务函数参数不定，
    就想到了c++11的变长参数模板。

时间：2021.07.18
使用C++11重构时，遇到的问题：
    1、将Connector的成员函数作为epoller的回调时，会出现Connector对象被释放的情况；
        解决方案：
            1、集成模板类 std::enable_shared_from_this<>，shared_from_this()将自身的智能指针绑定回调；

    2、使用优先级队列作为定时器管理的数据结构，但是优先级队列并没有删除指定元素的接口，于是封装了一个删除指定元素的接口；
       通过find_if在堆中查找指定元素，并删除它，然后重新调整堆；缺点：数据量大时，重新调整堆消耗大量资源；
    
    3.http一次请求过后，后续没有再使用该连接来请求时，会导致服务端的连接堆积，消耗服务端资源；
      解决方案： 
        通过将连接加入定时器，连续一定时间该连接没有请求到来，则释放该连接；
        
    4、处理过程中发现Message结构没有被释放，查看线程池取回调的操作，发现过程中用到的临时变量不是声明即定义，
        这样会导致该变量生命周期为整个程序运行生命周期，导致变量存储的回调对象一直未被释放；
      解决方案：
        存储回调的变量声明即定义，统称RALL;